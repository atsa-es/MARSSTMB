/// @file marxss2.hpp
// MARSS model with covariates

#ifndef marxss2_hpp
#define marxss2_hpp

#include "marssTMB/isNA.hpp"
#include "marssTMB/LOM.hpp"

#undef TMB_OBJECTIVE_PTR
#define TMB_OBJECTIVE_PTR obj

template<class Type>
Type marxss2(objective_function<Type>* obj) {
  DATA_MATRIX(Y); /* n x T */
  PARAMETER_MATRIX(X); /* State m x T */
  DATA_INTEGER(V0_is_zero);
  DATA_INTEGER(tinitx);
  DATA_IVECTOR(tfixed);
  DATA_IVECTOR(tfree);
  DATA_IVECTOR(npar);
  DATA_STRUCT(free, LOM); // list of free matrices
  DATA_STRUCT(fixed, LOM); // list of fixed matrices
  DATA_STRUCT(par_dims, LOVi); // list of par matrices
  PARAMETER_VECTOR(pars); /* vector of parameters */
  
  int timeSteps = Y.row(0).size();
  int nY = Y.col(0).size(); /* n x T */
  int nX = X.col(0).size(); /* m x T */
  
  // Set the non time-varying parameters
  matrix<Type> Qdiag(nX, nX);
  matrix<Type> Qoffdiag(nX, nX);
  Qdiag = parvec(fixed(9), free(9), par(pars, npar, 9), par_dims(9), tfree(9), tfixed(9), timeSteps);
  vector<Type> sdQ=Qdiag.col(0); /* sd of Q (diag) */
  sdQ = exp(sdQ);
  Qoffdiag = parvec(fixed(10), free(10), par(pars, npar, 10), par_dims(10), tfree(10), tfixed(10), timeSteps);
  vector<Type> cholCorrQ = Qoffdiag.col(0);
  matrix<Type> Rdiag(nY, nY);
  matrix<Type> Roffdiag(nY, nY);
  Rdiag = parvec(fixed(11), free(11), par(pars, npar, 11), par_dims(11), tfree(11), tfixed(11), timeSteps);
  vector<Type> sdR = Rdiag.col(0);
  sdR = exp(sdR);
  Roffdiag = parvec(fixed(12), free(12), par(pars, npar, 12), par_dims(12), tfree(12), tfixed(12), timeSteps);
  vector<Type> cholCorrR = Roffdiag.col(0);
  
  
  matrix<Type> x0(nX, 1);
  x0 = parmat(fixed(4), free(4), par(pars, npar, 4), par_dims(4));
  matrix<Type> V0(nX, nX);
  V0 = parmat(fixed(5), free(5), par(pars, npar, 5), par_dims(5));
  matrix<Type> U(nX, timeSteps);
  U = parvec(fixed(3), free(3), par(pars, npar, 3), par_dims(3), tfree(3), tfixed(3), timeSteps);
  matrix<Type> A(nY, timeSteps);
  A = parvec(fixed(1), free(1), par(pars, npar, 1), par_dims(1), tfree(1), tfixed(1), timeSteps);
  matrix<Type> Z(nX*nY, timeSteps);
  Z = parvec(fixed(0), free(0), par(pars, npar, 0), par_dims(0), tfree(0), tfixed(0), timeSteps);
  matrix<Type> B(nX*nX, timeSteps);
  B = parvec(fixed(2), free(2), par(pars, npar, 2), par_dims(2), tfree(2), tfixed(2), timeSteps);
  
  // https://kaskr.github.io/adcomp/classdensity_1_1UNSTRUCTURED__CORR__t.html
  using namespace density;
//  UNSTRUCTURED_CORR_t<Type> corMatGenR(cholCorrR);// This is the lower tri
//  matrix<Type> FullCorrMatR = corMatGenR.cov(); /* full corr matrix has 1 on diag */
//  UNSTRUCTURED_CORR_t<Type> corMatGenQ(cholCorrQ);// This is the lower tri
//  matrix<Type> FullCorrMatQ = corMatGenQ.cov(); /* full corr matrix has 1 on diag */
matrix<Type> FullCorrMatR(nY,nY);
FullCorrMatR.setIdentity();

  matrix<Type> predX(nX,1);  /* m x 1 */

  Type ans=0; /* Define likelihood */
  //ans -= dnorm(vector<Type>(u.row(0)),Type(0),Type(1),1).sum();
  if(V0_is_zero){
    if(tinitx){
      X.col(0) = x0;
    }else{
      predX = x0 + U.col(0);
      vector<Type> differ = X.col(0)-predX;
//      ans += VECSCALE(corMatGenQ,sdQ)(differ);
    }
  }else{
    // I think this is wrong if tinitx=0
    MVNORM_t<Type> initialState(V0);
    ans += initialState(X.col(0)-x0); /* tinitx=1 */
  }
  for(int i=1;i<timeSteps;i++){ 
    //ans+= neg_log_density_process(u.row(i)-u.row(i-1)); // Process likelihood
    //vector<Type> differ = u.row(i)-u.row(i-1);
    // if statement is temporary until I can figure how create a
    // a diagonal matrix with 1 on the -1 diagonal
    // diag(1:(timeSteps+1))[1:timeSteps, 2:(timeSteps+1)]
//    predX = X.col(i-1) + U.col(i);
//    vector<Type> differ = X.col(i)-predX;
//    ans += VECSCALE(corMatGenQ,sdQ)(differ);
  }
  
  matrix<Type> predY(nY, 1);  
  predY.setZero();
  matrix<Type> I(nY,nY);
  I.setIdentity();
  matrix<Type> Xi(1,nX);
  
  for(int i=0;i<timeSteps;i++){ //move one time step at a time
//    Xi = X.col(i).transpose();
//    predY = tmbutils::kronecker(I, Xi) * Z.col(i) + A.col(i);
    int nonNAcount = 0; //start at zero NA values
    vector<int> GoodVals(nY);
    for(int j=0;j<nY;j++){//loop over all time series for this time step
      if(!isNA(Y.col(i)(j))){//if value is not NA
        GoodVals(nonNAcount) = j; //add position to good values (good values only stored in beginning of vector)
        nonNAcount++; //increment the values of
      }
    }
    if(nonNAcount<nY){ //if NA values present
      matrix<Type> subCorr(nonNAcount,nonNAcount);
      vector<Type> subSds(nonNAcount);
      vector<Type> subData(nonNAcount);
      vector<Type> subPred(nonNAcount);
      
      for(int j=0;j<nonNAcount;j++){
        subData(j) = Y.col(i)(GoodVals(j));
        subPred(j) = predY(GoodVals(j));
        subSds(j) = sdR(GoodVals(j));
        for(int k=0;k<nonNAcount;k++){
          subCorr(j,k) = FullCorrMatR(GoodVals(j),GoodVals(k));
        }//end of loop through for truncated cormat
      }//end of removal of NA's from sets
      vector<Type> subDiffer = subData-subPred;
//      ans += VECSCALE(MVNORM(subCorr),subSds)(subDiffer);
    }else{
      vector<Type> differ = Y.col(i)-predY;
//      ans += VECSCALE(corMatGenR,sdR)(differ);
    }//end of data likelihood for this time step
  }//end of loop over time steps
  
  // Compute the full covariance matrices
//  matrix<Type> FullCovMatR(nY,nY);
//  matrix<Type> dSDR(nY,1);
//  dSDR = sdR;
//  FullCovMatR = dSDR.asDiagonal() * FullCorrMatR * dSDR.asDiagonal();
//  matrix<Type> FullCovMatQ(nX,nX);
//  matrix<Type> dSDQ(nX,1);
//  dSDQ = sdQ;
//  FullCovMatQ = dSDQ.asDiagonal() * FullCorrMatQ * dSDQ.asDiagonal();
  
  // Parameters with derivatives
  ADREPORT(X);
  ADREPORT(pars);

  // Report wo derivatives
//  REPORT(FullCorrMatQ);
//  REPORT(FullCovMatQ);
//  REPORT(FullCorrMatR);
//  REPORT(FullCovMatR);
  
  return ans;
}

#undef TMB_OBJECTIVE_PTR
#define TMB_OBJECTIVE_PTR this

#endif